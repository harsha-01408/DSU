Edge Strength

You are given a weighted tree with N nodes and N-1 edges.

E is defined as summation F(i, j) for all 1 ≤ i < j ≤ N.
Also, F(i, j) is equal to the maximum value of the edge that is present on the simple path between node i and j.

You are required to determine the value of E.

---

Input format:
• The first line contains an integer N denoting the number of nodes in a tree.
• The next N-1 lines contain three space-separated integers u, v and w denoting an edge 
  between node u and node v with weight w.

Output format:
• Print the required value of E.

---

Constraints:
1 ≤ N ≤ 2 × 10^5
1 ≤ w ≤ 10^6
1 ≤ u, v ≤ N

---

Example 1:
Input:
3
1 2 10
1 3 2

Output:
22

Explanation:
F(1,2) = 10
F(1,3) = 2
F(2,3) = 10
E = 10 + 2 + 10 = 22

---

Example 2:
Input:
5
1 2 4
2 3 1
1 4 6
4 5 12

Output:
75

Explanation:
F(1,2) = 4
F(1,3) = 4
F(1,4) = 6
F(1,5) = 12
F(2,3) = 1
F(2,4) = 6
F(2,5) = 12
F(3,4) = 6
F(3,5) = 12
F(4,5) = 12
E = 75


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx


A rider is about to start an Uber trip and needs to enter an OTP (One-Time Password)
to initiate the ride. The exact OTP required is unknown to the rider, but they are
provided with a list of n non-empty OTPs, each consisting of lowercase English
letters.

To guarantee starting the Uber trip, the rider needs to enter the correct OTP, or
any OTP that is considered equivalent to it. Determine the minimum number of OTPs
the rider must attempt to ensure they can start the trip, while minimizing the
number of OTPs tried.

Two OTPs A and B are considered equivalent if:

- There is at least one common character between A and B, OR
- There exists an OTP C in the list such that A is equivalent to C and B is
  equivalent to C (i.e., equivalence is transitive through chains of shared
  characters).

Input
- An integer n (1 ≤ n ≤ 10^4): the number of OTPs.
- A list of n strings: each string represents an OTP, consisting only of lowercase
  English letters 'a'–'z' with maximum length 50.

Output
- An integer representing the minimum number of OTPs the rider needs to try in
  order to guarantee that the trip can be initiated.

Example 1
Input:
4
["a", "b", "ab", "d"]

Output:
2

Explanation:
- OTPs "a", "b", and "ab" are equivalent because they can be connected through
  shared characters.
- OTP "d" is isolated and not equivalent to any of the others.
Thus there are 2 equivalence groups, so the rider must try at least 2 OTPs.

Example 2
Input:
1
["uber"]

Output:
1

Explanation:
- There is only one OTP provided, "uber". The rider must attempt this OTP.
So the minimum number of OTPs to try is 1.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

The country is a 2D coordinate grid with n servers. The i-th server is at (x[i], y[i]).

You may connect any two servers i and j. The cost of connecting them is:
cost(i, j) = min(|x[i] - x[j]|, |y[i] - y[j]|)

Choose a set of connections so that the network is fully connected, i.e., every server
is reachable from every other server (directly or through other servers).

Return the minimum possible total cost to make the network connected.

Function:
int getMinCost(vector<int> x, vector<int> y)

Input:
- x: array of x-coordinates
- y: array of y-coordinates

Output:
- minimum total cost to connect all servers

Constraints:
- 2 <= n <= 100000
- 0 <= x[i], y[i] <= 1000000000
- Multiple servers may have the same coordinates

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

You are given:
• An integer N
• M pairs of different lowercase English letters

Each given pair (u, v) indicates that u and v are “related”.
This relation is transitive: if (u, v) is related and (v, w) is related, then (u, w)
is also considered related.
Any two related characters are not allowed to appear next to each other in the
string.

Task
Find the number of strings of length N (using letters a–z) such that the string
does NOT contain any adjacent pair of related characters. Since the answer can be
very large, print it modulo (10^9 + 7).

Example
Assumptions:
• N = 2
• M = 3
• Pairs = {(a, b), (b, c), (c, d)}

Explanation (idea):
• From (a, b) and (b, c), transitivity implies (a, c) is also related.
• From (b, c) and (c, d), transitivity implies (b, d) is also related.
• Overall, {a, b, c, d} becomes one related group, so any two different letters
  among them cannot be adjacent.
• Forbidden adjacent pairs include:
  ab, ba, bc, cb, cd, dc, ac, ca, bd, db, ad, da
• Total strings of length 2 = 26^2 = 676
  Valid strings = 676 − 12 = 664

Function description
Complete the solve function. It receives:
• N: length of the string to form
• M: number of given pairs
• Pairs: list of M pairs of distinct characters

Input format
• First line: integer T (number of test cases)
• For each test case:
  – First line: integer N
  – Next line: integer M
  – Next M lines: two distinct lowercase characters per line

Output format
• For each test case, print the number of valid strings modulo (10^9 + 7).


XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
