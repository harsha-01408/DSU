Edge Strength

You are given a weighted tree with N nodes and N-1 edges.

E is defined as summation F(i, j) for all 1 ≤ i < j ≤ N.
Also, F(i, j) is equal to the maximum value of the edge that is present on the simple path between node i and j.

You are required to determine the value of E.

---

Input format:
• The first line contains an integer N denoting the number of nodes in a tree.
• The next N-1 lines contain three space-separated integers u, v and w denoting an edge 
  between node u and node v with weight w.

Output format:
• Print the required value of E.

---

Constraints:
1 ≤ N ≤ 2 × 10^5
1 ≤ w ≤ 10^6
1 ≤ u, v ≤ N

---

Example 1:
Input:
3
1 2 10
1 3 2

Output:
22

Explanation:
F(1,2) = 10
F(1,3) = 2
F(2,3) = 10
E = 10 + 2 + 10 = 22

---

Example 2:
Input:
5
1 2 4
2 3 1
1 4 6
4 5 12

Output:
75

Explanation:
F(1,2) = 4
F(1,3) = 4
F(1,4) = 6
F(1,5) = 12
F(2,3) = 1
F(2,4) = 6
F(2,5) = 12
F(3,4) = 6
F(3,5) = 12
F(4,5) = 12
E = 75


xxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxxx


A rider is about to start an Uber trip and needs to enter an OTP (One-Time Password)
to initiate the ride. The exact OTP required is unknown to the rider, but they are
provided with a list of n non-empty OTPs, each consisting of lowercase English
letters.

To guarantee starting the Uber trip, the rider needs to enter the correct OTP, or
any OTP that is considered equivalent to it. Determine the minimum number of OTPs
the rider must attempt to ensure they can start the trip, while minimizing the
number of OTPs tried.

Two OTPs A and B are considered equivalent if:

- There is at least one common character between A and B, OR
- There exists an OTP C in the list such that A is equivalent to C and B is
  equivalent to C (i.e., equivalence is transitive through chains of shared
  characters).

Input
- An integer n (1 ≤ n ≤ 10^4): the number of OTPs.
- A list of n strings: each string represents an OTP, consisting only of lowercase
  English letters 'a'–'z' with maximum length 50.

Output
- An integer representing the minimum number of OTPs the rider needs to try in
  order to guarantee that the trip can be initiated.

Example 1
Input:
4
["a", "b", "ab", "d"]

Output:
2

Explanation:
- OTPs "a", "b", and "ab" are equivalent because they can be connected through
  shared characters.
- OTP "d" is isolated and not equivalent to any of the others.
Thus there are 2 equivalence groups, so the rider must try at least 2 OTPs.

Example 2
Input:
1
["uber"]

Output:
1

Explanation:
- There is only one OTP provided, "uber". The rider must attempt this OTP.
So the minimum number of OTPs to try is 1.

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX

The country is a 2D coordinate grid with n servers. The i-th server is at (x[i], y[i]).

You may connect any two servers i and j. The cost of connecting them is:
cost(i, j) = min(|x[i] - x[j]|, |y[i] - y[j]|)

Choose a set of connections so that the network is fully connected, i.e., every server
is reachable from every other server (directly or through other servers).

Return the minimum possible total cost to make the network connected.

Function:
int getMinCost(vector<int> x, vector<int> y)

Input:
- x: array of x-coordinates
- y: array of y-coordinates

Output:
- minimum total cost to connect all servers

Constraints:
- 2 <= n <= 100000
- 0 <= x[i], y[i] <= 1000000000
- Multiple servers may have the same coordinates

XXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXXX
